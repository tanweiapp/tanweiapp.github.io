<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="iOS, 迷途小书僮" />










<meta name="description" content="1.Objective-C的起源Objective-C为C语言添加了面向对象特性，是其超集。并使用动态绑定的“消息结构”而非“函数调用”，也就是说，在运行时才会检查对象类型，接受到消息后，究竟应执行何种代码，由运行期环境来决定并非编译器。对于消息结构的语言，运行时所执行的代码由运行环境来决定；在运行时才回去查找索要执行的方法。其实现原理是由运行期组件完成（runtime component），使用">
<meta property="og:type" content="article">
<meta property="og:title" content="Effective Objective-C 读书笔记">
<meta property="og:url" content="http://yoursite.com/2018/03/23/Effective Objective-C 读书笔记01/index.html">
<meta property="og:site_name" content="迷途小书僮">
<meta property="og:description" content="1.Objective-C的起源Objective-C为C语言添加了面向对象特性，是其超集。并使用动态绑定的“消息结构”而非“函数调用”，也就是说，在运行时才会检查对象类型，接受到消息后，究竟应执行何种代码，由运行期环境来决定并非编译器。对于消息结构的语言，运行时所执行的代码由运行环境来决定；在运行时才回去查找索要执行的方法。其实现原理是由运行期组件完成（runtime component），使用">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="http://upload-images.jianshu.io/upload_images/2063843-629c143ce372ce80.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="http://upload-images.jianshu.io/upload_images/2063843-3968c7ac826d49ac.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:updated_time" content="2018-03-23T06:28:41.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Effective Objective-C 读书笔记">
<meta name="twitter:description" content="1.Objective-C的起源Objective-C为C语言添加了面向对象特性，是其超集。并使用动态绑定的“消息结构”而非“函数调用”，也就是说，在运行时才会检查对象类型，接受到消息后，究竟应执行何种代码，由运行期环境来决定并非编译器。对于消息结构的语言，运行时所执行的代码由运行环境来决定；在运行时才回去查找索要执行的方法。其实现原理是由运行期组件完成（runtime component），使用">
<meta name="twitter:image" content="http://upload-images.jianshu.io/upload_images/2063843-629c143ce372ce80.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '迷途小书僮'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2018/03/23/Effective Objective-C 读书笔记01/"/>





  <title>Effective Objective-C 读书笔记 | 迷途小书僮</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">迷途小书僮</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/03/23/Effective Objective-C 读书笔记01/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="迷途小书僮">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/picture.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="迷途小书僮">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">Effective Objective-C 读书笔记</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-03-23T10:55:40+08:00">
                2018-03-23
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h5 id="1-Objective-C的起源"><a href="#1-Objective-C的起源" class="headerlink" title="1.Objective-C的起源"></a>1.Objective-C的起源</h5><p>Objective-C为C语言添加了面向对象特性，是其超集。并使用动态绑定的“消息结构”而非“函数调用”，也就是说，在运行时才会检查对象类型，接受到消息后，究竟应执行何种代码，由运行期环境来决定并非编译器。对于消息结构的语言，运行时所执行的代码由运行环境来决定；在运行时才回去查找索要执行的方法。其实现原理是由运行期组件完成（runtime component），使用Objective-C的面向对象特性所需的全部数据结构以及函数都在运行期组件里面。</p>
<p>运行期组件本质上是一种与开发者所编写的代码相链接的动态库（dynamic library），其代码能把开发者所编写的所有程序粘合起来，所以只要更新运行期组件，就可以提升应用程序性能。</p>
<h5 id="2-在类的头文件中尽量少引用其他头文件"><a href="#2-在类的头文件中尽量少引用其他头文件" class="headerlink" title="2. 在类的头文件中尽量少引用其他头文件"></a>2. 在类的头文件中尽量少引用其他头文件</h5><p>有时，类A需要将类B的实例变量作为它公共API的属性。这个时候，我们不应该引入类B的头文件，而应该使用向前声明（forward declaring）使用class关键字，并且在A的实现文件引用B的头文件。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">// EOCPerson.h</span><br><span class="line">#import &lt;Foundation/Foundation.h&gt;</span><br><span class="line"></span><br><span class="line">@class EOCEmployer;</span><br><span class="line">//向前声明该类，只是告诉系统有这个类的存在，并不会编译这个的全部细节</span><br><span class="line"></span><br><span class="line">@interface EOCPerson : NSObject</span><br><span class="line"></span><br><span class="line">@property (nonatomic, copy) NSString *firstName;</span><br><span class="line">@property (nonatomic, copy) NSString *lastName;</span><br><span class="line">@property (nonatomic, strong) EOCEmployer *employer;//将EOCEmployer作为属性</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">// EOCPerson.m</span><br><span class="line">#import&quot;EOCPerson.h&quot;</span><br><span class="line">#import &quot;EOCEmployer.h&quot;</span><br><span class="line">@implementation EOCPerson</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure></p>
<p>这样处理的好处是:</p>
<blockquote>
<ul>
<li>不在类A头文件中引入类B的头文件，就不会将类B文件中的全部细节，尽量延后导入，从而减少了类使用者所需引入的头文件数量及编译时间.</li>
<li>当编译类A时需要知道类B，编译类B时需要知道类A时不在各自头文件中互相引用,使用向前声明可避免头文件循环引用.</li>
</ul>
</blockquote>
<p>特殊情况时需要在类头文件中引入其他头文件</p>
<blockquote>
<ul>
<li>该类继承于某个类，则应该引入父类的头文件。</li>
<li>该类遵从某个协议，则应该把“该类遵循某协议”的这条声明移至”class - continuation 分类”中,如果不行就把协议单独放在一个头文件中，然后将其引入。</li>
</ul>
</blockquote>
<h5 id="3-多用字面量语法，少用与之等价的方法"><a href="#3-多用字面量语法，少用与之等价的方法" class="headerlink" title="3. 多用字面量语法，少用与之等价的方法"></a>3. 多用字面量语法，少用与之等价的方法</h5><h6 id="1-字面量语法"><a href="#1-字面量语法" class="headerlink" title="1.字面量语法"></a>1.字面量语法</h6><p>在声明NSString， NSNumber，NSArray，NSDictionary时，应该尽量使用简洁字面量语法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">NSString *str = @&quot;abc&quot;;</span><br><span class="line">NSNumber *intNumber = @1;</span><br><span class="line">NSNumber *floatNumber = @2.5f;</span><br><span class="line"></span><br><span class="line">NSArray *animals =[NSArray arrayWithObjects:@&quot;cat&quot;,</span><br><span class="line">@&quot;dog&quot;,@&quot;mouse&quot;,</span><br><span class="line">@&quot;badger&quot;, nil];</span><br><span class="line"></span><br><span class="line">Dictionary *dict = @&#123;</span><br><span class="line">@&quot;animal&quot;:@&quot;tiger&quot;,</span><br><span class="line">@&quot;phone&quot;:@&quot;iPhone 6&quot;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h6 id="2-集合类取下标的字面量语法："><a href="#2-集合类取下标的字面量语法：" class="headerlink" title="2.集合类取下标的字面量语法："></a>2.集合类取下标的字面量语法：</h6><p>NSArray，NSDictionary，NSMutableArray，NSMutableDictionary 的取下标操作也应该尽量使用字面量语法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">NSArray *animals =[NSArray arrayWithObjects:@&quot;cat&quot;,</span><br><span class="line">@&quot;dog&quot;,@&quot;mouse&quot;,</span><br><span class="line">@&quot;badger&quot;, nil];</span><br><span class="line">Dictionary *dict = @&#123;</span><br><span class="line">@&quot;animal&quot;:@&quot;tiger&quot;,</span><br><span class="line">@&quot;phone&quot;:@&quot;iPhone 6&quot;</span><br><span class="line">&#125;;</span><br><span class="line">NSString *cat = animals[0];</span><br><span class="line">NSString *iphone = dict[@&quot;phone&quot;];</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>使用字面量语法的优点与注意点：</p>
<ul>
<li>代码可读性强，易于理解整洁美观。</li>
<li>使用字面量语法创建的数组或字典事，若值中有nil,则会抛出异常。因此，务必确保值里不含nil。</li>
<li>除了字符串以外，所创建出来的对象必须属于Foundation 框架才可以，自定义了这些类的子类是无法用字面量语法创建其对象。</li>
<li>使用字面量语法创建出来的字符串,数组,字典对大型都是不可变的，蹂想要可变版本的对象，则需要复制一份<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">NSMutableArray  *mutableArray = [@</span><br><span class="line">[@1,@2,@3,@4,@5]</span><br><span class="line">mutableCopy]</span><br></pre></td></tr></table></figure>
</li>
</ul>
</blockquote>
<h5 id="4-多用类型常量，少用-define预处理命令"><a href="#4-多用类型常量，少用-define预处理命令" class="headerlink" title="4. 多用类型常量，少用#define预处理命令"></a>4. 多用类型常量，少用#define预处理命令</h5><p>掌握了Objective-C与其C语言基础的人，定义常量通常使用预处理命令，但是并不建议使用它，而是使用类型常量的方法。</p>
<h6 id="两种方法定义常量的区别"><a href="#两种方法定义常量的区别" class="headerlink" title="两种方法定义常量的区别"></a>两种方法定义常量的区别</h6><blockquote>
<ul>
<li>预处理命令：简单的文本替换，没有类型信息，并且可被任意修改，多文件导入时，定义的预处理常量名称容易混淆。</li>
<li>类型常量：包括类型信息，并且可以设置其使用范围，而且不可被修改，便于编写开发文档</li>
</ul>
</blockquote>
<p>两种定义常量方式的具体使用</p>
<ul>
<li>预处理命令<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#define ANIMATION_DURATION 0.3</span><br></pre></td></tr></table></figure>
</li>
</ul>
<blockquote>
<p>这里：<br>0.3替换了ANIMATION_DURATION，它不具备ANIMATION_DURATION的类型信息.<br>这样的话，假设此指令声明在某个头文件中，那么所有引入了这个头文件的代码，其ANIMATION_DURATION都会被替换。</p>
</blockquote>
<ul>
<li>类型常量<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">static const NSTimeIntervalDuration = 0.3;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<blockquote>
<p>这里:<br>const 将其设置为常量，不可更改。<br>static意味着该变量仅仅在定义此变量的编译单元中可见。如果不声明static,编译器会为它创建一个外部符号（external symbol）。我们来看一下对外公开的常量的声明方法：</p>
</blockquote>
<h6 id="外部引用某个常量："><a href="#外部引用某个常量：" class="headerlink" title="外部引用某个常量："></a>外部引用某个常量：</h6><p>如果我们需要发送通知，那么就需要在不同的地方拿到通知的“频道”字符串(key)，那么显然这个字符串是不能被轻易更改，而且可以在不同的地方获取。这个时候就需要定义一个外界可见的字符串常量。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//header file</span><br><span class="line">extern NSString *const EOCStringConstant;</span><br><span class="line"></span><br><span class="line">//implementation file</span><br><span class="line">NSString *const  EOCStringConstant = @&quot;Finish Download&quot;;</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p> 这里NSString *const EOCStringConstant是指针常量。<br>extern关键字告诉编译器，在全局符号表中将会有一个名叫EOCStringConstant的符号。</p>
</blockquote>
<p>我们通常在头文件声明常量，在其实现文件里定义该常量。由实现文件生成目标文件时，编译器会在“数据段”为字符串分配存储空间。</p>
<blockquote>
<ul>
<li>注意常量名公开非公开的定义区别<br>公开的常量：常量的名字最好用与之相关的类名做前缀。<br>非公开的常量：局限于某个编译单元（tanslation unit，实现文件 implementation file）内，在签名加上字母k。<br>注意常量的名字。为避免冲突，最好使用与之相关的类名做前缀。</li>
</ul>
</blockquote>
<h5 id="5-用枚举表示状态，选项，状态码"><a href="#5-用枚举表示状态，选项，状态码" class="headerlink" title="5. 用枚举表示状态，选项，状态码"></a>5. 用枚举表示状态，选项，状态码</h5><p>我们通常需要给网络请求类定义几个状态，这些状态码可以用枚举来管理。下面是关于网络连接状态的状态码枚举：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">typedef NS_ENUM(NSUInteger, EOCConnectionState) &#123;</span><br><span class="line">EOCConnectionStateDisconnected,</span><br><span class="line">EOCConnectionStateConnecting,</span><br><span class="line">EOCConnectionStateConnected,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>在枚举类型的switch语句中不要实现default分支。它的好处是，当我们给枚举增加成员时，编译器就会提示开发者：switch语句并未处理所有的枚举。</p>
<h5 id="6-理解“属性”这一概念"><a href="#6-理解“属性”这一概念" class="headerlink" title="6. 理解“属性”这一概念"></a>6. 理解“属性”这一概念</h5><p>“属性”(property)是Objective-C的一项特性，用于封装对象中的数据</p>
<h6 id="1-存取方法"><a href="#1-存取方法" class="headerlink" title="1.存取方法"></a>1.存取方法</h6><p>在设置完属性后，编译器会自动写出一套存取方法，用于访问相应名称的变量：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">@interface EOCPerson : NSObject</span><br><span class="line"></span><br><span class="line">@property NSString *firstName;</span><br><span class="line">@property NSString *lastName;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@interface EOCPerson : NSObject</span><br><span class="line"></span><br><span class="line">- (NSString*)firstName;</span><br><span class="line">- (void)setFirstName:(NSString*)firstName;</span><br><span class="line">- (NSString*)lastName;</span><br><span class="line">- (void)setLastName:(NSString*)lastName;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure></p>
<p>要访问属性，可以使用点语法。编译器会把点语法转换为对存取方法的调用：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">aPerson.firstName = @&quot;Bob&quot;; // Same as:</span><br><span class="line">[aPerson setFirstName:@&quot;Bob&quot;];</span><br><span class="line"></span><br><span class="line">NSString *lastName = aPerson.lastName; // Same as:</span><br><span class="line">NSString *lastName = [aPerson lastName];</span><br></pre></td></tr></table></figure></p>
<p>若我们不希望编译器自动生成存取合成方法的话，需要设置@dynamic 字段：系统默认为(@synthesize 自动生成合成方法)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@interface EOCPerson : NSManagedObject</span><br><span class="line"></span><br><span class="line">@property NSString *firstName;</span><br><span class="line">@property NSString *lastName;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation EOCPerson</span><br><span class="line">@dynamic firstName, lastName;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure></p>
<h6 id="2-属性特质"><a href="#2-属性特质" class="headerlink" title="2. 属性特质"></a>2. 属性特质</h6><blockquote>
<p>定义属性的时候，通常会赋予它一些修饰，来满足一些对类保存数据所要遵循的需求(编译器合成存取方法时根据此特质来决定所生成的代码)。</p>
</blockquote>
<h6 id="原子性："><a href="#原子性：" class="headerlink" title="原子性："></a>原子性：</h6><ul>
<li>nonatomic：不使用同步锁</li>
<li>atomic：加同步锁，确保其原子性</li>
</ul>
<h6 id="读写权限"><a href="#读写权限" class="headerlink" title="读写权限"></a>读写权限</h6><ul>
<li>readwrite:(读写)同时拥有存取方法</li>
<li>readonly:(只读)只拥有获取方法，开发中一般在头文件中使用此特质对外公开某属性为只读属性,然后在实现文件类扩展中(class-continuation分类)中将其重新定义为读写属性</li>
</ul>
<h6 id="内存管理语义"><a href="#内存管理语义" class="headerlink" title="内存管理语义"></a>内存管理语义</h6><ul>
<li>assign:纯量类型(scalar type，基本数据类型)的简单赋值操作</li>
<li>strong:拥有关系保留新值，释放旧值，再设置新值</li>
<li>weak:非拥有关系(nonowning relationship)，属性所指的对象遭到摧毁时，属性也会清空</li>
<li>unsafe_unretained ：类似assign，适用于对象类型，非拥有关系，属性所指的对象遭到摧毁时，属性不会清空。</li>
<li>copy：不保留新值，而是将其拷贝</li>
<li>注意遵循属性语义：如果属性定义为copy，那么在非设置方法里设定属性的时候，也要遵循copy的语义<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">- (id)initWithFirstName:(NSString*)firstName lastName:(NSString*)lastName</span><br><span class="line">&#123;</span><br><span class="line">if ((self = [super init])) &#123;</span><br><span class="line">_firstName = [firstName copy];</span><br><span class="line">_lastName = [lastName copy];</span><br><span class="line">&#125;</span><br><span class="line">return self;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h5 id="7-在对象内部尽量直接访问实例变量"><a href="#7-在对象内部尽量直接访问实例变量" class="headerlink" title="7.在对象内部尽量直接访问实例变量"></a>7.在对象内部尽量直接访问实例变量</h5><p>关于实例变量的访问，在对象内部访问实例变量时，应该直接通过实例变量来读取，而写入数据时，则应通过属性来写入。</p>
<h6 id="直接访问属性"><a href="#直接访问属性" class="headerlink" title="直接访问属性"></a>直接访问属性</h6><ul>
<li>会直接绕过setter方法和getter方法，直接读取实例变量,访问速度相对比较快。</li>
<li>并不会触发“键值观测”（KVO）<br>######通过属性访问属性的特点：</li>
<li>通过属性访问有助于排查与之相关的错误，监控该属性的调用者及访问时机。</li>
<li>会触发“键值观测”（KVO）</li>
<li>会读取相关属性所定义的“内存语义”setter方法和getter方法<blockquote>
<p>折中方案:</p>
<ul>
<li>设置属性：通过属性</li>
<li>读取属性：直接访问</li>
</ul>
</blockquote>
</li>
</ul>
<p>选用这个折中方案时，需要注意以下两点:</p>
<ul>
<li>1.初始化方法和dealloc方法中，需要直接访问实例变量来进行设置属性操作。因为如果在这里没有绕过set方法，就有可能触发其他不必要的操作。</li>
<li>2.惰性初始化（lazy initialization）的属性，必须通过属性来读取数据。因为惰性初始化是通过重写get方法来初始化实例变量的，如果不通过属性来读取该实例变量，那么这个实例变量就永远不会被初始化。</li>
</ul>
<h5 id="8-理解“对象等同性”这一概念"><a href="#8-理解“对象等同性”这一概念" class="headerlink" title="8. 理解“对象等同性”这一概念"></a>8. 理解“对象等同性”这一概念</h5><h6 id="1-等同性判断"><a href="#1-等同性判断" class="headerlink" title="1. 等同性判断"></a>1. 等同性判断</h6><blockquote>
<p>==操作符比较的是指针值本身，而不是其所指对象。比较指针所指向的内容，在这个时候，就需要通过isEqual:方法来比较。一般来说，两个类型不同的对象总是不相等的。如果已知两个对象都属于同一个类，那么就可以使用这种方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">NSString *foo = @&quot;abcd&quot;;</span><br><span class="line">NSString *bar = [NSString StringWithFormat:@&quot;Badge&quot;];</span><br><span class="line">BOOL equalA = (foo == bar); //&lt; equalA = NO;</span><br><span class="line">BOOL equalB = [foo isEqual: bar]; // &lt; equalB = YES;</span><br><span class="line">BOOL equalC = [foo isEqualToString:bar]; // &lt; equalC = YES</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p>如果已知两个对象是字符串，最好通过isEqualToString:方法来比较。<br>对于数组和字典，也有isEqualToArray:方法和isEqualToDictionary:方法。</p>
</blockquote>
<p>如果比较的对象类型和当前对象类型相同，就可以采用自己编写的判定方法，否则调用父类的isEqual:方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">- (BOOL)isEqualToPerson:(EOCPerson*)otherPerson &#123;</span><br><span class="line"></span><br><span class="line">//先比较对象类型，然后比较每个属性</span><br><span class="line">if (self == object) return YES;</span><br><span class="line">if (![_firstName isEqualToString:otherPerson.firstName])</span><br><span class="line">return NO;</span><br><span class="line">if (![_lastName isEqualToString:otherPerson.lastName])</span><br><span class="line">return NO;</span><br><span class="line">if (_age != otherPerson.age)</span><br><span class="line">return NO;</span><br><span class="line">return YES;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- (BOOL)isEqual:(id)object &#123;</span><br><span class="line">//如果对象所属类型相同，就调用自己编写的判定方法，如果不同，调用父类的isEqual:方法</span><br><span class="line">if ([self class] == [object class]) &#123;</span><br><span class="line">return [self isEqualToPerson:(EOCPerson*)object];</span><br><span class="line">&#125; else &#123;</span><br><span class="line">return [super isEqual:object];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h6 id="2-等同性判定的执行深度"><a href="#2-等同性判定的执行深度" class="headerlink" title="2. 等同性判定的执行深度"></a>2. 等同性判定的执行深度</h6><p>NSArray 的检测方式为先看两个数组所含对象个数是否相同，若相同，则在每个对应位置的两个对象身上调用其“isEqual”方法。如果对应位置上的对象均相等，那么这个两个数组就相等，不过有时候无须将所有数据逐个比较，只根据其中部分数据即可判明二者是否等同。</p>
<blockquote>
<ul>
<li>若想检测对象的等同性，请提供”isEqual:” 与hash方法。</li>
<li>相同的对象必须具有相同的哈希码，但是两个哈希码相同的对象却未必相同。</li>
<li>不要盲目地逐个检测每条属性，而是应该依照具体需求来制定检测方案。</li>
<li>编写hash方法时，应该使用计算速度快而且hash码碰撞几率低的算法。</li>
</ul>
</blockquote>
<h5 id="9-以“类族模式“隐藏实现细节"><a href="#9-以“类族模式“隐藏实现细节" class="headerlink" title="9. 以“类族模式“隐藏实现细节"></a>9. 以“类族模式“隐藏实现细节</h5><p>“类簇”是一种很有用的模式，通过隐藏“抽象基类”来实例化不同的实体子类。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">+ (UIButton *)buttonWithType:(UIButtonType)type;</span><br></pre></td></tr></table></figure></p>
<p>根据传入不同的按钮类型(UIButtonType)就可以得到不同的UIButton的子类。不要考虑绘制方式，实现细节。</p>
<h6 id="创建类族"><a href="#创建类族" class="headerlink" title="- 创建类族"></a>- 创建类族</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">//EOCEmployee.h</span><br><span class="line"></span><br><span class="line">typedef NS_ENUM(NSUInteger, EOCEmployeeType) &#123;</span><br><span class="line">EOCEmployeeTypeDeveloper,</span><br><span class="line">EOCEmployeeTypeDesigner,</span><br><span class="line">EOCEmployeeTypeFinance,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">@interface EOCEmployee : NSObject</span><br><span class="line"></span><br><span class="line">@property (copy) NSString *name;</span><br><span class="line">@property NSUInteger salary;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// Helper for creating Employee objects</span><br><span class="line">+ (EOCEmployee*)employeeWithType:(EOCEmployeeType)type;</span><br><span class="line"></span><br><span class="line">// Make Employees do their respective day&apos;s work</span><br><span class="line">- (void)doADaysWork;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">//EOCEmployee.m</span><br><span class="line"></span><br><span class="line">@implementation EOCEmployee</span><br><span class="line"></span><br><span class="line">+ (EOCEmployee*)employeeWithType:(EOCEmployeeType)type &#123;</span><br><span class="line">switch (type) &#123;</span><br><span class="line">case EOCEmployeeTypeDeveloper:</span><br><span class="line">return [EOCEmployeeDeveloper new];</span><br><span class="line">break;</span><br><span class="line"></span><br><span class="line">case EOCEmployeeTypeDesigner:</span><br><span class="line">return [EOCEmployeeDesigner new];</span><br><span class="line">break;</span><br><span class="line"></span><br><span class="line">case EOCEmployeeTypeFinance:</span><br><span class="line">return [EOCEmployeeFinance new];</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)doADaysWork &#123;</span><br><span class="line">// 需要子类来实现</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<h6 id="实体子类（concrete-subclass）"><a href="#实体子类（concrete-subclass）" class="headerlink" title="- 实体子类（concrete subclass）:"></a>- 实体子类（concrete subclass）:</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@interface EOCEmployeeDeveloper : EOCEmployee</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation EOCEmployeeDeveloper</span><br><span class="line"></span><br><span class="line">- (void)doADaysWork &#123;</span><br><span class="line">[self writeCode];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<h6 id="Cocoa-里的类簇"><a href="#Cocoa-里的类簇" class="headerlink" title="Cocoa 里的类簇:"></a>Cocoa 里的类簇:</h6><p>系统中有许多类簇，大部分collection类都是类簇，如NSArray 与NSMutableArray,实际上有两个抽象基类,一个用于可变数组，另一个用于不可变数组，尽管具备公共接口的类有两个，但仍然可以合起来算作一个类簇。</p>
<blockquote>
<p>######注意:<br>  如果对象所属的类位于某个类族中，那么在查询类型信息时就要小心。因为类族中的实体子类并不与其基类属于同一个类。</p>
</blockquote>
<h5 id="10-在既有类中使用关联对象存放自定义数据"><a href="#10-在既有类中使用关联对象存放自定义数据" class="headerlink" title="10.在既有类中使用关联对象存放自定义数据"></a>10.在既有类中使用关联对象存放自定义数据</h5><p>我们可以给某对象“关联对象”其它对象把两个对象连起来，这些对象通过”键”类区分。存储对象值的时候，可以指明”存储策略”,这样我们就可以从某个对象中获取相应的关联对象的值。</p>
<ul>
<li>设置关联对象:<br><code>void objc_setAssociatedObject(id object, void *key, id value, objc_AssociationPolicy policy</code></li>
</ul>
<blockquote>
<p> 这里，d object 参数是主对象，void *key参数是键，id value参数是关联的对象，objc_AssociationPolicy参数是存储策略:是枚举，定义了内存管理语义。</p>
</blockquote>
<p>关联类型    等效的@property属性<br>OBJC_ASSOCIATION_ASSIGN ————————- assign<br>OBJC_ASSOCIATION_RETAIN_NONATOMIC ———— nonatomic, retain<br>OBJC_ASSOCIATION_COPY_NONATOMIC ————– nonatomic,copy<br>OBJC_ASSOCIATION_RETAIN ————————– retain<br>OBJC_ASSOCIATION_COPY —————————- copy</p>
<ul>
<li>获取关联对象<br><code>id objc_getAssociatedObject(id object, void *key)</code></li>
<li>删除关联对象<br><code>void objc_removeAssociatedObjects(id object)</code><blockquote>
<p>我们可以把某对象想象成NSDictionary,把关联到该对象的值理解为字典中的条目，存取关联对象的值就相当于NSDictionary对象上调用存值取值方法，这两者间有个重要差别:设置关联对象时用的键是个“不透明的指针”，所以在设置关联对象值时通常使用静态全局变量做键。<br>关联对象用法举例</p>
</blockquote>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">#import &lt;objc/runtime.h&gt;</span><br><span class="line"></span><br><span class="line">static void *EOCMyAlertViewKey = &quot;EOCMyAlertViewKey&quot;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- (void)askUserAQuestion &#123;</span><br><span class="line"></span><br><span class="line">UIAlertView *alert = [[UIAlertView alloc] initWithTitle:@&quot;Question&quot;</span><br><span class="line">message:@&quot;What do you want to do?&quot;</span><br><span class="line">delegate:self</span><br><span class="line">cancelButtonTitle:@&quot;Cancel&quot;</span><br><span class="line">otherButtonTitles:@&quot;Continue&quot;, nil];</span><br><span class="line"></span><br><span class="line">void (^block)(NSInteger) = ^(NSInteger buttonIndex)&#123;</span><br><span class="line"></span><br><span class="line">if (buttonIndex == 0) &#123;</span><br><span class="line">[self doCancel];</span><br><span class="line">&#125; else &#123;</span><br><span class="line">[self doContinue];</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//将alert和block关联在了一起</span><br><span class="line">objc_setAssociatedObject(alert,EOCMyAlertViewKey,block, OBJC_ASSOCIATION_COPY);</span><br><span class="line">[alert show];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// UIAlertViewDelegate protocol method</span><br><span class="line">- (void)alertView:(UIAlertView*)alertView clickedButtonAtIndex:(NSInteger)buttonIndex</span><br><span class="line">&#123;</span><br><span class="line">//alert取出关联的block</span><br><span class="line">void (^block)(NSInteger) = objc_getAssociatedObject(alertView, EOCMyAlertViewKey)</span><br><span class="line">//给block传入index值</span><br><span class="line">block(buttonIndex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="11-理解objc-msgSend的作用"><a href="#11-理解objc-msgSend的作用" class="headerlink" title="11.理解objc_msgSend的作用"></a>11.理解objc_msgSend的作用</h5><p>在Objective-C中，如果向某对象传递信息，那就会使用动态绑定机制来决定需要调用的方法。在底层，所有方法都是普通的C语言函数.对象收到消息后，究竟该调用那个方法则完全由运行期决定,甚至可以在程序运行时改变，这些特性使得OC成为一门真正的动态语言。</p>
<p>给对象发送消息可以这样写：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">id returnValue = [someObject messageName:parameter];</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>样例中，someObject叫做“接收者(receiver)”，messageName:叫做”选择子（selector）”,选择子和参数合起来称为“消息”。编译器看到此消息后，将其转换为一条标准的C语言函数调用，所调用的函数乃是消息传递机制中的核心函数叫做objc_msgSend，它的原型如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void objc_msgSend(id self, SEL cmd, ...)</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p>参数中id参数代表接收者，SEL参数代表选择子，…参数就是消息中的那些参数，数量是可变的，所以这个函数就是参数个数可变的函数。</p>
</blockquote>
<p>鉴于此，上述以Objective-C形式展现出来的函数就会转化成如下函数:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">id returnValue = objc_msgSend(someObject,@selector(messageName:),parameter);</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>该方法会在接收者所属的类中搜寻其“方法列表”，如果能找到与选择子名称相符的方法，就去实现代码，如果找不到就沿着继承体系继续向上查找。如果找到了就执行，如果最终还是找不到，就执行<strong>消息转发</strong>操作。</p>
</blockquote>
<p>如果找到对应的选择子匹配成功的话，这种匹配的结果会缓存在“快速映射表”里面。每个类都有这样一块缓存。所以如果将来再次向该类发送形同的消息，执行速度就会更快了。</p>
<h5 id="12-理解消息转发机制"><a href="#12-理解消息转发机制" class="headerlink" title="12.理解消息转发机制"></a>12.理解消息转发机制</h5><p>如果对象所属类和其所有的父类都无法解读收到的消息，就会启动<strong>消息转发机制（message forwarding）</strong>。</p>
<p>消息转发过程中以应用程序崩溃而告终，开发者在编写自己累得额同时，可与转发过程中设置挂钩，用以执行预订单额逻辑，而不使应用程序崩溃。</p>
<p>消息转发分为两大阶段;</p>
<ul>
<li>1.征询接受者，看它能否动态添加方法，以处理这个未知的选择子，这个过程叫做动态方法解析（dynamic method resolution）。</li>
<li>2.请接受者看看有没有其他对象能处理这条消息：</li>
<li>2.1. 请接收者查看有没有其他对象能处理这条消息,如果有，则运行期系统会把消息转给那个对象。</li>
<li>2.2 如果没有，则启动完整的消息转发机制（full forwarding mechanism），运行期系统会把与消息有关的全部细节都封装到NSInvocation对象中，再给接受者最后一次机会，令其设法解决当前还未处理的这条消息。</li>
</ul>
<p>对象在收到无法解读的消息后，首先将调用其所属类的+(BOOL)resolveInstanceMethod:(SEL)selector，并查看这个类是否能新增一个实例方法用以处理此选择子。</p>
<p>实例方法- (id)forwardTargetForSelector:(SEL)selector;:询问是否能找到未知消息的备援接受者，如果能找到备援对象，就将其返回，如果不能，就返回nil。</p>
<p>实例方法- (void)forwardInvocation:(NSInvocation*)invocation:创建NSInvocation对象，将尚未处理的那条消息 有关的全部细节都封于其中，在触发NSInvocation对象时，“消息派发系统（message-dispatch system）”就会将消息派给目标对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">#import &lt;Foundation/Foundation.h&gt;</span><br><span class="line"></span><br><span class="line">@interface EOCAutoDictionary : NSObject</span><br><span class="line">@property (nonatomic, strong) NSString *string;</span><br><span class="line">@property (nonatomic, strong) NSNumber *number;</span><br><span class="line">@property (nonatomic, strong) NSDate *date;</span><br><span class="line">@property (nonatomic, strong) id opaqueObject;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#import &quot;EOCAutoDictionary.h&quot;</span><br><span class="line">#import &lt;objc/runtime.h&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@interface EOCAutoDictionary ()</span><br><span class="line">@property (nonatomic, strong) NSMutableDictionary *backingStore;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation EOCAutoDictionary</span><br><span class="line"></span><br><span class="line">@dynamic string, number, date, opaqueObject;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- (id)init &#123;</span><br><span class="line">if ((self = [super init])) &#123;</span><br><span class="line">_backingStore = [NSMutableDictionary new];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">return self;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">+ (BOOL)resolveInstanceMethod:(SEL)selector &#123;</span><br><span class="line"></span><br><span class="line">NSString *selectorString = NSStringFromSelector(selector);</span><br><span class="line">if ([selectorString hasPrefix:@&quot;set&quot;]) &#123;</span><br><span class="line">class_addMethod(self,selector,(IMP)autoDictionarySetter, &quot;v@:@&quot;);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">class_addMethod(self,selector,(IMP)autoDictionaryGetter, &quot;@@:&quot;);</span><br><span class="line">&#125;</span><br><span class="line">return YES;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>在本例中，EOCAutoDictionary类将属性设置为@dynamic，也就是说编译器无法自动为其属性生成set和get方法，因此我们需要动态给其添加set和get方法。</p>
</blockquote>
<blockquote>
<p>我们实现了resolveInstanceMethod:方法：首先将选择子转换为String，然后判断字符串是否含有set字段，如果有，则增加处理选择子的set方法；如果没有，则增加处理选择子的get方法。其中class_addMethod可以给类动态添加方法。</p>
</blockquote>
<h6 id="消息转发全流程图"><a href="#消息转发全流程图" class="headerlink" title="消息转发全流程图"></a>消息转发全流程图<img src="http://upload-images.jianshu.io/upload_images/2063843-629c143ce372ce80.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图片来自：《Effective Objective-C 》"></h6><p>实现增加处理选择子的get方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">id autoDictionaryGetter(id self, SEL _cmd) &#123;</span><br><span class="line"></span><br><span class="line">// Get the backing store from the object</span><br><span class="line">EOCAutoDictionary *typedSelf = (EOCAutoDictionary*)self;</span><br><span class="line">NSMutableDictionary *backingStore = typedSelf.backingStore;</span><br><span class="line"></span><br><span class="line">// The key is simply the selector name</span><br><span class="line">NSString *key = NSStringFromSelector(_cmd);</span><br><span class="line"></span><br><span class="line">// Return the value</span><br><span class="line">return [backingStore objectForKey:key];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>实现增加处理选择子的set方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">void autoDictionarySetter(id self, SEL _cmd, id value) &#123;</span><br><span class="line"></span><br><span class="line">// Get the backing store from the object</span><br><span class="line">EOCAutoDictionary *typedSelf = (EOCAutoDictionary*)self;</span><br><span class="line">NSMutableDictionary *backingStore = typedSelf.backingStore;</span><br><span class="line"></span><br><span class="line">/** The selector will be for example, &quot;setOpaqueObject:&quot;.</span><br><span class="line">* We need to remove the &quot;set&quot;, &quot;:&quot; and lowercase the first</span><br><span class="line">* letter of the remainder.</span><br><span class="line">*/</span><br><span class="line">NSString *selectorString = NSStringFromSelector(_cmd);</span><br><span class="line">NSMutableString *key = [selectorString mutableCopy];</span><br><span class="line"></span><br><span class="line">// Remove the &apos;:&apos; at the end</span><br><span class="line">[key deleteCharactersInRange:NSMakeRange(key.length - 1, 1)];</span><br><span class="line"></span><br><span class="line">// Remove the &apos;set&apos; prefix</span><br><span class="line">[key deleteCharactersInRange:NSMakeRange(0, 3)];</span><br><span class="line"></span><br><span class="line">// Lowercase the first character</span><br><span class="line">NSString *lowercaseFirstChar = [[key substringToIndex:1] lowercaseString];</span><br><span class="line">[key replaceCharactersInRange:NSMakeRange(0, 1) withString:lowercaseFirstChar];</span><br><span class="line"></span><br><span class="line">if (value) &#123;</span><br><span class="line">[backingStore setObject:value forKey:key];</span><br><span class="line">&#125; else &#123;</span><br><span class="line">[backingStore removeObjectForKey:key];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h5 id="13-用“方法调配技术”调试“黑盒方法”"><a href="#13-用“方法调配技术”调试“黑盒方法”" class="headerlink" title="13.用“方法调配技术”调试“黑盒方法”"></a>13.用“方法调配技术”调试“黑盒方法”</h5><p>与给定选择子名称相对应的方法是可以在运行期被改变的，所以，我们可以不用通过继承类并覆写方法就能改变这个类本身的功能。</p>
<p>类的方法列表会把选择子的名称映射到相关的方法实现之上，使得”动态消息派发系统”能够据此找到应该调用的方法，这些方法均以函数指针的形式来表示，这种指针叫做IMP，通过操纵类的方法列表的IMP指针。<br><img src="http://upload-images.jianshu.io/upload_images/2063843-3968c7ac826d49ac.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="类方法表的映射"></p>
<blockquote>
<p>现在，如果我们调用lowercaseString方法就会实际调用uppercaseString的方法，反之亦然。</p>
</blockquote>
<p>实际开发中，直接交换两个方法的实现，意义并不大。不过，我们应该利用这个特性来给既有的方法添加新功能。</p>
<ul>
<li>实现原理是：先通过分类增加一个新方法，然后将这个新方法和要增加功能的旧方法替换（旧方法名 对应新方法的实现），这样一来，如果我们调用了旧方法，就会实现新方法了</li>
</ul>
<p>需求: 我们要在原有的lowercaseString方法中添加一条log输出语句。</p>
<ul>
<li><p>1.我们先将新方法写在NSString的分类里：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">@interface NSString (EOCMyAdditions)</span><br><span class="line">- (NSString*)eoc_myLowercaseString;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@implementation NSString (EOCMyAdditions)</span><br><span class="line"></span><br><span class="line">- (NSString*)eoc_myLowercaseString &#123;</span><br><span class="line">NSString *lowercase = [self eoc_myLowercaseString];</span><br><span class="line">//这段代码看上去好像会陷入递归调用的循环中，</span><br><span class="line">//不过eoc_myLowercaseString方法会在将来方法调换后执行lowercaseString的方法</span><br><span class="line"></span><br><span class="line">NSLog(@&quot;%@ =&gt; %@&quot;, self, lowercase);//输出语句，便于调试</span><br><span class="line">return lowercase;</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
</li>
<li><ol>
<li>交换两个方法的实现（操纵调换IMP指针）<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Method originalMethod =</span><br><span class="line">class_getInstanceMethod([NSString class],</span><br><span class="line">@selector(lowercaseString));</span><br><span class="line">Method swappedMethod =</span><br><span class="line">class_getInstanceMethod([NSString class],</span><br><span class="line">@selector(eoc_myLowercaseString));</span><br><span class="line"></span><br><span class="line">method_exchangeImplementations(originalMethod, swappedMethod);</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
</ul>
<p>我们如果交换了lowercaseString和eoc_myLowercaseString的方法实现，那么在调用原来的lowercaseString方法后就可以输出新增的语句了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">“NSString *string = @&quot;ThIs iS tHe StRiNg&quot;;</span><br><span class="line">NSString *lowercaseString = [string lowercaseString];</span><br><span class="line">// Output: ThIs iS tHe StRiNg =&gt; this is the string”</span><br></pre></td></tr></table></figure></p>
<h5 id="14-理解“类对象”的用意"><a href="#14-理解“类对象”的用意" class="headerlink" title="14.理解“类对象”的用意"></a>14.理解“类对象”的用意</h5><p>Objective-C对象所用的数据结构定义子啊运行期程序库的头文件里<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">typedef struct objc_class *Class;</span><br><span class="line"></span><br><span class="line">struct objc_class &#123;</span><br><span class="line">Class isa;</span><br><span class="line">Class super_class;</span><br><span class="line">const char *name;</span><br><span class="line">long version;</span><br><span class="line">long info;</span><br><span class="line">long instance_size;</span><br><span class="line">struct objc_ivar_list *ivars;</span><br><span class="line">struct objc_method_list **methodLists;</span><br><span class="line">struct objc_cache *cache;</span><br><span class="line">struct objc_protocol_list *protocols;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>每个对象结构体的收个成员是Class类的变量，该变量定义了对象所属的类，通常称为”isa指针”， isa指针指向了对象所属的类：元类（metaclass），它是整个结构体的第一个变量。super_class定义了本类的超类。</p>
<ul>
<li>在类继承体系中查询类型信息<br>可以用类型信息查询方法来检视类继承体系，能够判断出对象是否为某个特定类的实例和判断出对象是否为某类或其派生类的实例。<br>我们使用<code>isMemberOfClass:</code>能够判断出对象是否为某个特定类的实例；<br>而<code>isKindOfClass:</code>方法能够判断出对象是否为某类或其派生类的实例。<br>这两种方法都是利用了isa指针获取对象所属的类，然后通过super_class类在继承体系中查询。在OC语言中，必须使用这种查询类型信息的方法才能完全了解对象的真实类型。因为对象类型无法在编译期决定</li>
</ul>
</blockquote>
<p>尤其注意在集合类里获取对象时，通常要查询类型信息因为这些对象不是强类型的（strongly typed），将它们从集合类中取出来的类型通常是id，也就是能响应任何消息（编译期）。</p>
<p>所以如果我们对这些对象的类型把握不好，那么就会有可能造成对象无法响应消息的情况。因此，在我们从集合里取出对象后，通常要进行类型判断：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">- (NSString*)commaSeparatedStringFromObjects:(NSArray*)array &#123;</span><br><span class="line"></span><br><span class="line">NSMutableString *string = [NSMutableString new];</span><br><span class="line"></span><br><span class="line">for (id object in array) &#123;</span><br><span class="line">if ([object isKindOfClass:[NSString class]]) &#123;</span><br><span class="line">[string appendFormat:@&quot;%@,&quot;, object];</span><br><span class="line">&#125; else if ([object isKindOfClass:[NSNumber class]]) &#123;</span><br><span class="line">[string appendFormat:@&quot;%d,&quot;, [object intValue]];</span><br><span class="line">&#125; else if ([object isKindOfClass:[NSData class]]) &#123;</span><br><span class="line">NSString *base64Encoded = /* base64 encoded data */;</span><br><span class="line">[string appendFormat:@&quot;%@,&quot;, base64Encoded];</span><br><span class="line">&#125; else &#123;</span><br><span class="line">// Type not supported</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return string;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<blockquote>
<ul>
<li>每个实例都有一个指向Class对象的指针，用以表明其类型，而这些Class对象则构成了类的继承体系。</li>
<li>如果对象类型无法在编译期确定，那么就应该使用类型信息查询方法来探知。</li>
<li>尽量使用类型信息查询方法来确定对象类型，而不要直接比较类对象，因为某些对象可能实现了消息转发功能。</li>
</ul>
</blockquote>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2018/03/23/Effective Objective-C 读书笔记03/" rel="next" title="Effective Objective-C 读书笔记03">
                <i class="fa fa-chevron-left"></i> Effective Objective-C 读书笔记03
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2018/03/23/Effective Objective-C 读书笔记02/" rel="prev" title="Effective Objective-C 读书笔记02">
                Effective Objective-C 读书笔记02 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/picture.png"
                alt="迷途小书僮" />
            
              <p class="site-author-name" itemprop="name">迷途小书僮</p>
              <p class="site-description motion-element" itemprop="description">iOS技术学习博客</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">7</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">1</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            

          </nav>

          

          

          
          

          
          
            <div class="links-of-blogroll motion-element links-of-blogroll-block">
              <div class="links-of-blogroll-title">
                <i class="fa  fa-fw fa-link"></i>
                Links
              </div>
              <ul class="links-of-blogroll-list">
                
                  <li class="links-of-blogroll-item">
                    <a href="https://www.jianshu.com/u/66baf1c26b43" title="迷途小书僮简书" target="_blank">迷途小书僮简书</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="https://gitee.com/452567933" title="OSChina" target="_blank">OSChina</a>
                  </li>
                
              </ul>
            </div>
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-Objective-C的起源"><span class="nav-number">1.</span> <span class="nav-text">1.Objective-C的起源</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-在类的头文件中尽量少引用其他头文件"><span class="nav-number">2.</span> <span class="nav-text">2. 在类的头文件中尽量少引用其他头文件</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-多用字面量语法，少用与之等价的方法"><span class="nav-number">3.</span> <span class="nav-text">3. 多用字面量语法，少用与之等价的方法</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#1-字面量语法"><span class="nav-number">3.1.</span> <span class="nav-text">1.字面量语法</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#2-集合类取下标的字面量语法："><span class="nav-number">3.2.</span> <span class="nav-text">2.集合类取下标的字面量语法：</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-多用类型常量，少用-define预处理命令"><span class="nav-number">4.</span> <span class="nav-text">4. 多用类型常量，少用#define预处理命令</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#两种方法定义常量的区别"><span class="nav-number">4.1.</span> <span class="nav-text">两种方法定义常量的区别</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#外部引用某个常量："><span class="nav-number">4.2.</span> <span class="nav-text">外部引用某个常量：</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#5-用枚举表示状态，选项，状态码"><span class="nav-number">5.</span> <span class="nav-text">5. 用枚举表示状态，选项，状态码</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#6-理解“属性”这一概念"><span class="nav-number">6.</span> <span class="nav-text">6. 理解“属性”这一概念</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#1-存取方法"><span class="nav-number">6.1.</span> <span class="nav-text">1.存取方法</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#2-属性特质"><span class="nav-number">6.2.</span> <span class="nav-text">2. 属性特质</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#原子性："><span class="nav-number">6.3.</span> <span class="nav-text">原子性：</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#读写权限"><span class="nav-number">6.4.</span> <span class="nav-text">读写权限</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#内存管理语义"><span class="nav-number">6.5.</span> <span class="nav-text">内存管理语义</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#7-在对象内部尽量直接访问实例变量"><span class="nav-number">7.</span> <span class="nav-text">7.在对象内部尽量直接访问实例变量</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#直接访问属性"><span class="nav-number">7.1.</span> <span class="nav-text">直接访问属性</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#8-理解“对象等同性”这一概念"><span class="nav-number">8.</span> <span class="nav-text">8. 理解“对象等同性”这一概念</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#1-等同性判断"><span class="nav-number">8.1.</span> <span class="nav-text">1. 等同性判断</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#2-等同性判定的执行深度"><span class="nav-number">8.2.</span> <span class="nav-text">2. 等同性判定的执行深度</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#9-以“类族模式“隐藏实现细节"><span class="nav-number">9.</span> <span class="nav-text">9. 以“类族模式“隐藏实现细节</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#创建类族"><span class="nav-number">9.1.</span> <span class="nav-text">- 创建类族</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#实体子类（concrete-subclass）"><span class="nav-number">9.2.</span> <span class="nav-text">- 实体子类（concrete subclass）:</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#Cocoa-里的类簇"><span class="nav-number">9.3.</span> <span class="nav-text">Cocoa 里的类簇:</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#10-在既有类中使用关联对象存放自定义数据"><span class="nav-number">10.</span> <span class="nav-text">10.在既有类中使用关联对象存放自定义数据</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#11-理解objc-msgSend的作用"><span class="nav-number">11.</span> <span class="nav-text">11.理解objc_msgSend的作用</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#12-理解消息转发机制"><span class="nav-number">12.</span> <span class="nav-text">12.理解消息转发机制</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#消息转发全流程图"><span class="nav-number">12.1.</span> <span class="nav-text">消息转发全流程图</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#13-用“方法调配技术”调试“黑盒方法”"><span class="nav-number">13.</span> <span class="nav-text">13.用“方法调配技术”调试“黑盒方法”</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#14-理解“类对象”的用意"><span class="nav-number">14.</span> <span class="nav-text">14.理解“类对象”的用意</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; 2016 &mdash; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">迷途小书僮</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
